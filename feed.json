{"title":"神经漫游者","description":"擅长各项后端技能，研究移动端开发与后端性能。此为博客一枚。","language":"","link":"//aha.me","pubDate":"Mon, 14 Oct 2019 01:31:44 GMT","lastBuildDate":"Mon, 14 Oct 2019 03:53:12 GMT","generator":"hexo-generator-json-feed","webMaster":"Kaleldo","items":[{"title":"mybatis where 中遇到传入集合参数问题","link":"//aha.me/2019/10/14/mybatis-where-中遇到传入集合参数问题/","description":"mybatis where 中in的使用 当我们使用mybatis时，在where中会用到 in 如： where name in (‘Jana’,’Tom’); 我们可以在sql中直接写 name in (‘Jana’,’Tom’) 或者 name in (${names}) （备注：String names = “‘JOJO’,’TOM’”; 使用$时会引起sql注入安全问题） 但是我们无法在sql中直接写 name in (#{names}); 会报参数个数错误，因为’Jana’,’Tom’会被解析成两个传参 String[] names={“Jana”,”Tom”}; 此时要用foreach函数：","pubDate":"Mon, 14 Oct 2019 01:31:44 GMT","guid":"//aha.me/2019/10/14/mybatis-where-中遇到传入集合参数问题/","category":"mybatis"},{"title":"编程提升","link":"//aha.me/2019/10/08/编程提升/","description":"接口总结资源防盗用 （高并发大数据之防止并解决web资源防盗链）","pubDate":"Tue, 08 Oct 2019 07:11:05 GMT","guid":"//aha.me/2019/10/08/编程提升/","category":"项目小结"},{"title":"项目需求分析(付费会员,超级领主)","link":"//aha.me/2019/10/08/项目需求分析/","description":"项目总结(付费会员,超级领主)","pubDate":"Tue, 08 Oct 2019 06:33:47 GMT","guid":"//aha.me/2019/10/08/项目需求分析/","category":"付费会员,超级领主,项目总结"},{"title":"Centos7部署yapi","link":"//aha.me/2019/10/08/20191008p2p项目总结/","description":"生产环境 mongodb node pm2 yapi","pubDate":"Tue, 08 Oct 2019 01:42:23 GMT","guid":"//aha.me/2019/10/08/20191008p2p项目总结/","category":"Centos7,文档,接口,node"},{"title":"Ajax跨域请求，同时保证session一致","link":"//aha.me/2019/04/17/Ajax跨域请求，同时保证session一致/","description":"最近在项目中碰到一个问题，ajax跨域请求时，每次tomcat都会生成一个新的session。 在百度中找到了解决方法。http://blog.sina.com.cn/s/blog_e774c01e0102we37.html 当我们在进行跨域访问的时候，我们的sessionId就不会被保存下来，也就是说，每一次的请求，服务器就会以为是一个新的人，而不是同一个人，为了解决这样的办法，需要对跨域访问的request头部重写。","pubDate":"Wed, 17 Apr 2019 02:13:24 GMT","guid":"//aha.me/2019/04/17/Ajax跨域请求，同时保证session一致/","category":"springBoot"},{"title":"轻松搞定数据验证（二）","link":"//aha.me/2019/02/19/轻松搞定数据验证（二）/","description":"一起来学SpringBoot | 第十九篇：轻松搞定数据验证（一） 中介绍了数据有效性校验的重要性，也简单介绍了如何用轻松的方式搞定数据有效性校验，但是当系统自带的注解无法满足我们的要求时候应该咋办呢？这就是本章将给各位介绍的自定义 Validator 注解","pubDate":"Tue, 19 Feb 2019 14:19:38 GMT","guid":"//aha.me/2019/02/19/轻松搞定数据验证（二）/","category":"springBoot,轻松搞定数据验证（二）"},{"title":"轻松搞定数据验证（一）","link":"//aha.me/2019/02/19/轻松搞定数据验证（一）/","description":"对于任何一个应用而言，客户端做的数据有效性验证都不是安全有效的，而数据验证又是一个企业级项目架构上最为基础的功能模块，这时候就要求我们在服务端接收到数据的时候也对数据的有效性进行验证。为什么这么说呢？往往我们在编写程序的时候都会感觉后台的验证无关紧要，毕竟客户端已经做过验证了，后端没必要在浪费资源对数据进行验证了，但恰恰是这种思维最为容易被别人钻空子。毕竟只要有点开发经验的都知道，我们完全可以模拟 HTTP 请求到后台地址，模拟请求过程中发送一些涉及系统安全的数据到后台，后果可想而知….","pubDate":"Tue, 19 Feb 2019 13:48:23 GMT","guid":"//aha.me/2019/02/19/轻松搞定数据验证（一）/","category":"springBoot,轻松搞定数据验证（一）"},{"title":"轻松搞定全局异常","link":"//aha.me/2019/02/19/轻松搞定全局异常/","description":"实际项目开发中，程序往往会发生各式各样的异常情况，特别是身为服务端开发人员的我们，总是不停的编写接口提供给前端调用，分工协作的情况下，避免不了异常的发生，如果直接将错误的信息直接暴露给用户，这样的体验可想而知，且对黑客而言，详细异常信息往往会提供非常大的帮助…","pubDate":"Tue, 19 Feb 2019 13:30:31 GMT","guid":"//aha.me/2019/02/19/轻松搞定全局异常/","category":"springBoot,轻松搞定全局异常"},{"title":"定时任务详解","link":"//aha.me/2019/02/19/定时任务详解/","description":"在我们日常开发中，经常会遇到 数据定时增量同步、定时发送邮件、爬虫定时抓取 的需求；这时我们可以采用定时任务的方式去进行工作…..","pubDate":"Tue, 19 Feb 2019 05:36:49 GMT","guid":"//aha.me/2019/02/19/定时任务详解/","category":"springBoot"},{"title":"集成Swagger在线调试","link":"//aha.me/2019/02/18/集成Swagger在线调试/","description":"随着互联网技术的发展，现在的网站架构基本都由原来的后端渲染，变成了：前端渲染、前后端分离的形态，而且前端技术和后端技术在各自的道路上越走越远。 前端和后端唯一联系，变成了API接口；API文档自然就成了前后端开发人员联系的纽带，变得尤为的重要，swagger就是一款让你更好的书写API文档的框架。","pubDate":"Mon, 18 Feb 2019 13:47:32 GMT","guid":"//aha.me/2019/02/18/集成Swagger在线调试/","category":"springBoot,集成Swagger在线调试"},{"title":"使用Spring Cache集成Redis","link":"//aha.me/2019/02/18/使用Spring-Cache集成Redis/","description":"Spring 3.1 引入了激动人心的基于注释（annotation）的缓存（cache）技术，它本质上不是一个具体的缓存实现方案（例如 EHCache 或者 Redis），而是一个对缓存使用的抽象，通过在既有代码中添加少量它定义的各种 annotation，即能够达到缓存方法的返回对象的效果。","pubDate":"Mon, 18 Feb 2019 11:09:26 GMT","guid":"//aha.me/2019/02/18/使用Spring-Cache集成Redis/","category":"springBoot,使用Spring Cache集成Redis"},{"title":"整合Lettuce Redis","link":"//aha.me/2019/02/18/整合Lettuce-Redis/","description":"Spring Boot 除了支持常见的ORM框架外，更是对常用的中间件提供了非常好封装，随着Spring Boot2.x的到来，支持的组件越来越丰富，也越来越成熟，其中对Redis的支持不仅仅是丰富了它的API，更是替换掉底层Jedis的依赖，取而代之换成了Lettuce(生菜)","pubDate":"Mon, 18 Feb 2019 10:53:07 GMT","guid":"//aha.me/2019/02/18/整合Lettuce-Redis/","category":"springBoot"},{"title":"通用Mapper与分页插件的集成","link":"//aha.me/2019/02/18/通用Mapper与分页插件的集成/","description":"在没有分页插件之前，写一个分页需要两条SQL语句，一条查询一条统计，然后才能计算出页码，这样的代码冗余而又枯燥，更重要的一点是数据库迁移，众所周知不同的数据库分页写法是不同的，而Mybatis不同于Hibernate的是它只提供动态SQL和结果集映射。值得庆幸的是，它虽然没有为分页提供良好的解决方案，但却提供了Interceptor以供开发者自己扩展，这也是这款分页插件的由来….","pubDate":"Mon, 18 Feb 2019 05:15:35 GMT","guid":"//aha.me/2019/02/18/通用Mapper与分页插件的集成/","category":"springBoot,通用Mapper与分页插件的集成"},{"title":"整合SpringDataJpa","link":"//aha.me/2019/02/17/整合SpringDataJpa/","description":"JPAJPA是Java Persistence API的简称，中文名Java持久层API，是官方（Sun）在JDK5.0后提出的Java持久化规范。其目的是为了简化现有JAVA EE和JAVA SE应用开发工作，以及整合现有的ORM技术实现规范统一","pubDate":"Sun, 17 Feb 2019 14:35:51 GMT","guid":"//aha.me/2019/02/17/整合SpringDataJpa/","category":"springBoot,SpringDataJpa"},{"title":"JSON.stringify出现Converting circular structure to JSON","link":"//aha.me/2019/02/16/JSON-stringify出现Converting-circular-structure-to-JSON/","description":"123456789101112131415var cache = []; var row1 = JSON.stringify(row, function (key, value) &#123; if (typeof value === 'object' &amp;&amp; value !== null) &#123; if (cache.indexOf(value) !== -1) &#123; // Circular reference found, discard key return; &#125; // Store value in our collection cache.push(value); &#125; return value; &#125;); cache = null; window.localStorage.setItem(\"row\", row1); console.log(JSON.parse(localStorage.getItem(\"row\")));","pubDate":"Sat, 16 Feb 2019 15:10:36 GMT","guid":"//aha.me/2019/02/16/JSON-stringify出现Converting-circular-structure-to-JSON/","category":"JSON"},{"title":"菜单管理 解决表单回显","link":"//aha.me/2019/02/16/菜单管理-解决表单回显/","description":"解决表单回显","pubDate":"Sat, 16 Feb 2019 15:06:59 GMT","guid":"//aha.me/2019/02/16/菜单管理-解决表单回显/","category":"springBoot"},{"title":"layui 使用弹窗功能及树控件","link":"//aha.me/2019/02/16/layui-使用弹窗功能及树控件/","description":"","pubDate":"Sat, 16 Feb 2019 15:04:36 GMT","guid":"//aha.me/2019/02/16/layui-使用弹窗功能及树控件/","category":"layui"},{"title":"layui 引入插件","link":"//aha.me/2019/02/16/layui-引入插件/","description":"12345layui.config(&#123; base: Main.getContextPath()+'/assets/plugins/layui/lay/modules/' //假设这是test.js所在的目录 可以把你需要扩展的js插件都放在一个文件夹内&#125;).extend(&#123; //设定组件别名 dtree: 'dtree'&#125;);","pubDate":"Sat, 16 Feb 2019 15:02:26 GMT","guid":"//aha.me/2019/02/16/layui-引入插件/","category":"layui"},{"title":"layui 使用layui 扩展组件 dtree","link":"//aha.me/2019/02/16/layui-使用layui-扩展组件-dtree/","description":"","pubDate":"Sat, 16 Feb 2019 14:56:14 GMT","guid":"//aha.me/2019/02/16/layui-使用layui-扩展组件-dtree/","category":"layui"},{"title":"layui dtree 树形组件 elem和obj的区别 目的解决了弹窗关闭后再打开出现空白树","link":"//aha.me/2019/02/16/layui-dtree-树形组件-elem和obj的区别-目的解决了弹窗关闭后再打开出现空白树/","description":"elem：树绑定的元素ID。 obj：树绑定的DOM。使用elem元素可以绑定已经在页面中存在的元素，而如果是页面中点击某个按钮生成的元素的话，则可以用obj来指定，这在使用layer.open()中打开一个树极为有效，它可以规避元素在生成之前被绑定从而找不到的问题。最终组件会将elem转换为该属性，elem和obj属性必须指定一个，如果同时指定，则优先obj属性的配置项","pubDate":"Sat, 16 Feb 2019 14:53:45 GMT","guid":"//aha.me/2019/02/16/layui-dtree-树形组件-elem和obj的区别-目的解决了弹窗关闭后再打开出现空白树/","category":"layui"},{"title":"layui dtree 树形组件使用递归处理返回数据","link":"//aha.me/2019/02/16/layui-dtree-树形组件使用递归处理返回数据/","description":"递归处理返回数据","pubDate":"Sat, 16 Feb 2019 14:49:24 GMT","guid":"//aha.me/2019/02/16/layui-dtree-树形组件使用递归处理返回数据/","category":"layui"},{"title":"JAVA中分为基本数据类型及引用数据类型","link":"//aha.me/2019/02/16/JAVA中分为基本数据类型及引用数据类型/","description":"一、基本数据类型：","pubDate":"Sat, 16 Feb 2019 14:45:49 GMT","guid":"//aha.me/2019/02/16/JAVA中分为基本数据类型及引用数据类型/","category":"Java基础"},{"title":"layui 弹出层复选框反选数据","link":"//aha.me/2019/02/16/layui-弹出层复选框反选数据/","description":"","pubDate":"Sat, 16 Feb 2019 14:41:28 GMT","guid":"//aha.me/2019/02/16/layui-弹出层复选框反选数据/","category":"layui"},{"title":"treegrid.js BootstrapTable进行封装","link":"//aha.me/2019/02/16/treegrid-js-BootstrapTable进行封装/","description":"main.js","pubDate":"Sat, 16 Feb 2019 14:39:05 GMT","guid":"//aha.me/2019/02/16/treegrid-js-BootstrapTable进行封装/","category":"前端"},{"title":"java提高篇（一）—–理解java的三大特性之封装","link":"//aha.me/2019/02/16/java提高篇（一）—–理解java的三大特性之封装/","description":"三大特性之—封装封装从字面上来理解就是包装的意思，专业点就是信息隐藏，是指利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体，数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。系统的其他对象只能通过包裹在数据外面的已经授权的操作来与这个封装的对象进行交流和交互。也就是说用户是无需知道对象内部的细节（当然也无从知道），但可以通过该对象对外的提供的接口来访问该对象。","pubDate":"Sat, 16 Feb 2019 14:34:18 GMT","guid":"//aha.me/2019/02/16/java提高篇（一）—–理解java的三大特性之封装/","category":"java提高"}]}