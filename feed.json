{"title":"神经漫游者","description":"擅长各项后端技能，研究移动端开发与后端性能。此为博客一枚。","language":"","link":"//aha.me","pubDate":"Thu, 17 Oct 2019 02:16:21 GMT","lastBuildDate":"Thu, 17 Oct 2019 02:17:15 GMT","generator":"hexo-generator-json-feed","webMaster":"Kaleldo","items":[{"title":"花里胡哨的死信队列","link":"//aha.me/2019/10/17/花里胡哨的死信队列/","description":"死信队列(DLX)Dead-Letter-Exchange 利用DLX, 当消息在一个队列中变成死信(dead message)之后, 它能被重新publish到另一个Exchange, 这个Exchange就是 DLXDLX也是一个正常的Exchange, 和一般的Exchange没有区别, 它能在任何队列上被指定, 实际上就是设置某个队列的属性为死信队列","pubDate":"Thu, 17 Oct 2019 02:16:21 GMT","guid":"//aha.me/2019/10/17/花里胡哨的死信队列/","category":"项目小结"},{"title":"spring与RabbitMq的一些花里胡哨纷争","link":"//aha.me/2019/10/17/spring与RabbitMq的一些花里胡哨纷争/","description":"SimpleMessageListenerContainer 简单消息监听容器 这个类功能很强大, 对于消费者的配置项, 这份都可以实现 监听队列(支持多个队列), 自动启动, 自动声明等设置事务特性, 事务管理器, 事务属性, 事务容量(并发), 是否开启事务, 回滚消息等 可以设置消费者数量, 最小最大数量, 批量消费等设置消息确认和自动确认模式, 是否重回队列, 异常捕获Handler函数 设置消费者标签生成策略, 是否独占模式, 消费者属性等设置具体的消息监听器, 消息转换器等 SimpleMessageListenerContainer可以进行动态设置,比如在运行中的应用可以动态的修改其消费者数量的大小, 接收消息的模式等, 很多基于RabbitMQ的定制的后端管控台进行动态设置的时候,也是基于这一特性去实现的","pubDate":"Thu, 17 Oct 2019 01:55:39 GMT","guid":"//aha.me/2019/10/17/spring与RabbitMq的一些花里胡哨纷争/","category":"中间件"},{"title":"docker花里胡哨的网络配置","link":"//aha.me/2019/10/16/docker花里胡哨的网络配置/","description":"网络配置 docker默认提供了三种网络模式：bridge、host和none。其中bridge是Docker默认的网络模式，在该模式下，容器拥有自己的IPnamespace，容器可以通过宿主机上的docker0网桥与别的容器、宿主机或者外部网络进行通信。如果想要让容器内服务可以让外部环境访问到,我们可以通过端口映射的方式让外部环境也能访问到容器内部资源。","pubDate":"Wed, 16 Oct 2019 02:58:04 GMT","guid":"//aha.me/2019/10/16/docker花里胡哨的网络配置/","category":"docker"},{"title":"工作中一些docker花里胡哨使用总结","link":"//aha.me/2019/10/15/工作中一些docker花里胡哨使用总结/","description":"Docker安装-命令安装环境为centos7 123456789 yum install -y yum-utils device-mapper-persistent-data lvm2 yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo【注意：当上面链接（官网）无法连接时，使用下面镜像地址 sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo】 yum-config-manager --enable docker-ce-edgeyum-config-manager --enable docker-ce-testyum-config-manager --disable docker-ce-edgeyum makecache fastyum install docker-ce","pubDate":"Tue, 15 Oct 2019 07:44:06 GMT","guid":"//aha.me/2019/10/15/工作中一些docker花里胡哨使用总结/","category":"docker"},{"title":"工作中常用的cat命令","link":"//aha.me/2019/10/15/工作中常用的cat命令/","description":"查看日志线上出现了问题，登上线上的机器查日志是非常常见的操作了。我第一次登上线上机器查日志的时候，我还只记得以下的几个命令（假设现在我们的日志文件叫做service.log)：","pubDate":"Tue, 15 Oct 2019 02:26:45 GMT","guid":"//aha.me/2019/10/15/工作中常用的cat命令/","category":"常用命令"},{"title":"git工作中常用命令","link":"//aha.me/2019/10/15/git工作中常用命令/","description":"Git常用命令 从远端库更新内容到本地 1git pull 把文件添加到缓冲区 12git add &lt;filename&gt; // 添加某文件git add . // 添加所有文件","pubDate":"Tue, 15 Oct 2019 00:36:03 GMT","guid":"//aha.me/2019/10/15/git工作中常用命令/","category":"工作总结"},{"title":"mybatis where 中遇到传入集合参数问题","link":"//aha.me/2019/10/14/mybatis-where-中遇到传入集合参数问题/","description":"mybatis where 中in的使用 当我们使用mybatis时，在where中会用到 in 如： where name in (‘Jana’,’Tom’); 我们可以在sql中直接写 name in (‘Jana’,’Tom’) 或者 name in (${names}) （备注：String names = “‘JOJO’,’TOM’”; 使用$时会引起sql注入安全问题） 但是我们无法在sql中直接写 name in (#{names}); 会报参数个数错误，因为’Jana’,’Tom’会被解析成两个传参 String[] names={“Jana”,”Tom”}; 此时要用foreach函数：","pubDate":"Mon, 14 Oct 2019 01:31:44 GMT","guid":"//aha.me/2019/10/14/mybatis-where-中遇到传入集合参数问题/","category":"mybatis"},{"title":"编程提升","link":"//aha.me/2019/10/08/编程提升/","description":"接口总结资源防盗用 （高并发大数据之防止并解决web资源防盗链）","pubDate":"Tue, 08 Oct 2019 07:11:05 GMT","guid":"//aha.me/2019/10/08/编程提升/","category":"项目小结"},{"title":"项目需求分析(付费会员,超级领主)","link":"//aha.me/2019/10/08/项目需求分析/","description":"项目总结(付费会员,超级领主)","pubDate":"Tue, 08 Oct 2019 06:33:47 GMT","guid":"//aha.me/2019/10/08/项目需求分析/","category":"付费会员,超级领主,项目总结"},{"title":"Centos7部署yapi","link":"//aha.me/2019/10/08/20191008p2p项目总结/","description":"生产环境 mongodb node pm2 yapi","pubDate":"Tue, 08 Oct 2019 01:42:23 GMT","guid":"//aha.me/2019/10/08/20191008p2p项目总结/","category":"Centos7,文档,接口,node"},{"title":"Ajax跨域请求，同时保证session一致","link":"//aha.me/2019/04/17/Ajax跨域请求，同时保证session一致/","description":"最近在项目中碰到一个问题，ajax跨域请求时，每次tomcat都会生成一个新的session。 在百度中找到了解决方法。http://blog.sina.com.cn/s/blog_e774c01e0102we37.html 当我们在进行跨域访问的时候，我们的sessionId就不会被保存下来，也就是说，每一次的请求，服务器就会以为是一个新的人，而不是同一个人，为了解决这样的办法，需要对跨域访问的request头部重写。","pubDate":"Wed, 17 Apr 2019 02:13:24 GMT","guid":"//aha.me/2019/04/17/Ajax跨域请求，同时保证session一致/","category":"springBoot"},{"title":"轻松搞定数据验证（二）","link":"//aha.me/2019/02/19/轻松搞定数据验证（二）/","description":"一起来学SpringBoot | 第十九篇：轻松搞定数据验证（一） 中介绍了数据有效性校验的重要性，也简单介绍了如何用轻松的方式搞定数据有效性校验，但是当系统自带的注解无法满足我们的要求时候应该咋办呢？这就是本章将给各位介绍的自定义 Validator 注解","pubDate":"Tue, 19 Feb 2019 14:19:38 GMT","guid":"//aha.me/2019/02/19/轻松搞定数据验证（二）/","category":"springBoot,轻松搞定数据验证（二）"},{"title":"轻松搞定数据验证（一）","link":"//aha.me/2019/02/19/轻松搞定数据验证（一）/","description":"对于任何一个应用而言，客户端做的数据有效性验证都不是安全有效的，而数据验证又是一个企业级项目架构上最为基础的功能模块，这时候就要求我们在服务端接收到数据的时候也对数据的有效性进行验证。为什么这么说呢？往往我们在编写程序的时候都会感觉后台的验证无关紧要，毕竟客户端已经做过验证了，后端没必要在浪费资源对数据进行验证了，但恰恰是这种思维最为容易被别人钻空子。毕竟只要有点开发经验的都知道，我们完全可以模拟 HTTP 请求到后台地址，模拟请求过程中发送一些涉及系统安全的数据到后台，后果可想而知….","pubDate":"Tue, 19 Feb 2019 13:48:23 GMT","guid":"//aha.me/2019/02/19/轻松搞定数据验证（一）/","category":"springBoot,轻松搞定数据验证（一）"},{"title":"轻松搞定全局异常","link":"//aha.me/2019/02/19/轻松搞定全局异常/","description":"实际项目开发中，程序往往会发生各式各样的异常情况，特别是身为服务端开发人员的我们，总是不停的编写接口提供给前端调用，分工协作的情况下，避免不了异常的发生，如果直接将错误的信息直接暴露给用户，这样的体验可想而知，且对黑客而言，详细异常信息往往会提供非常大的帮助…","pubDate":"Tue, 19 Feb 2019 13:30:31 GMT","guid":"//aha.me/2019/02/19/轻松搞定全局异常/","category":"springBoot,轻松搞定全局异常"},{"title":"定时任务详解","link":"//aha.me/2019/02/19/定时任务详解/","description":"在我们日常开发中，经常会遇到 数据定时增量同步、定时发送邮件、爬虫定时抓取 的需求；这时我们可以采用定时任务的方式去进行工作…..","pubDate":"Tue, 19 Feb 2019 05:36:49 GMT","guid":"//aha.me/2019/02/19/定时任务详解/","category":"springBoot"},{"title":"集成Swagger在线调试","link":"//aha.me/2019/02/18/集成Swagger在线调试/","description":"随着互联网技术的发展，现在的网站架构基本都由原来的后端渲染，变成了：前端渲染、前后端分离的形态，而且前端技术和后端技术在各自的道路上越走越远。 前端和后端唯一联系，变成了API接口；API文档自然就成了前后端开发人员联系的纽带，变得尤为的重要，swagger就是一款让你更好的书写API文档的框架。","pubDate":"Mon, 18 Feb 2019 13:47:32 GMT","guid":"//aha.me/2019/02/18/集成Swagger在线调试/","category":"springBoot,集成Swagger在线调试"},{"title":"使用Spring Cache集成Redis","link":"//aha.me/2019/02/18/使用Spring-Cache集成Redis/","description":"Spring 3.1 引入了激动人心的基于注释（annotation）的缓存（cache）技术，它本质上不是一个具体的缓存实现方案（例如 EHCache 或者 Redis），而是一个对缓存使用的抽象，通过在既有代码中添加少量它定义的各种 annotation，即能够达到缓存方法的返回对象的效果。","pubDate":"Mon, 18 Feb 2019 11:09:26 GMT","guid":"//aha.me/2019/02/18/使用Spring-Cache集成Redis/","category":"springBoot,使用Spring Cache集成Redis"},{"title":"整合Lettuce Redis","link":"//aha.me/2019/02/18/整合Lettuce-Redis/","description":"Spring Boot 除了支持常见的ORM框架外，更是对常用的中间件提供了非常好封装，随着Spring Boot2.x的到来，支持的组件越来越丰富，也越来越成熟，其中对Redis的支持不仅仅是丰富了它的API，更是替换掉底层Jedis的依赖，取而代之换成了Lettuce(生菜)","pubDate":"Mon, 18 Feb 2019 10:53:07 GMT","guid":"//aha.me/2019/02/18/整合Lettuce-Redis/","category":"springBoot"},{"title":"通用Mapper与分页插件的集成","link":"//aha.me/2019/02/18/通用Mapper与分页插件的集成/","description":"在没有分页插件之前，写一个分页需要两条SQL语句，一条查询一条统计，然后才能计算出页码，这样的代码冗余而又枯燥，更重要的一点是数据库迁移，众所周知不同的数据库分页写法是不同的，而Mybatis不同于Hibernate的是它只提供动态SQL和结果集映射。值得庆幸的是，它虽然没有为分页提供良好的解决方案，但却提供了Interceptor以供开发者自己扩展，这也是这款分页插件的由来….","pubDate":"Mon, 18 Feb 2019 05:15:35 GMT","guid":"//aha.me/2019/02/18/通用Mapper与分页插件的集成/","category":"springBoot,通用Mapper与分页插件的集成"},{"title":"整合SpringDataJpa","link":"//aha.me/2019/02/17/整合SpringDataJpa/","description":"JPAJPA是Java Persistence API的简称，中文名Java持久层API，是官方（Sun）在JDK5.0后提出的Java持久化规范。其目的是为了简化现有JAVA EE和JAVA SE应用开发工作，以及整合现有的ORM技术实现规范统一","pubDate":"Sun, 17 Feb 2019 14:35:51 GMT","guid":"//aha.me/2019/02/17/整合SpringDataJpa/","category":"springBoot,SpringDataJpa"},{"title":"JSON.stringify出现Converting circular structure to JSON","link":"//aha.me/2019/02/16/JSON-stringify出现Converting-circular-structure-to-JSON/","description":"123456789101112131415var cache = []; var row1 = JSON.stringify(row, function (key, value) &#123; if (typeof value === 'object' &amp;&amp; value !== null) &#123; if (cache.indexOf(value) !== -1) &#123; // Circular reference found, discard key return; &#125; // Store value in our collection cache.push(value); &#125; return value; &#125;); cache = null; window.localStorage.setItem(\"row\", row1); console.log(JSON.parse(localStorage.getItem(\"row\")));","pubDate":"Sat, 16 Feb 2019 15:10:36 GMT","guid":"//aha.me/2019/02/16/JSON-stringify出现Converting-circular-structure-to-JSON/","category":"JSON"},{"title":"菜单管理 解决表单回显","link":"//aha.me/2019/02/16/菜单管理-解决表单回显/","description":"解决表单回显","pubDate":"Sat, 16 Feb 2019 15:06:59 GMT","guid":"//aha.me/2019/02/16/菜单管理-解决表单回显/","category":"springBoot"},{"title":"layui 使用弹窗功能及树控件","link":"//aha.me/2019/02/16/layui-使用弹窗功能及树控件/","description":"","pubDate":"Sat, 16 Feb 2019 15:04:36 GMT","guid":"//aha.me/2019/02/16/layui-使用弹窗功能及树控件/","category":"layui"},{"title":"layui 引入插件","link":"//aha.me/2019/02/16/layui-引入插件/","description":"12345layui.config(&#123; base: Main.getContextPath()+'/assets/plugins/layui/lay/modules/' //假设这是test.js所在的目录 可以把你需要扩展的js插件都放在一个文件夹内&#125;).extend(&#123; //设定组件别名 dtree: 'dtree'&#125;);","pubDate":"Sat, 16 Feb 2019 15:02:26 GMT","guid":"//aha.me/2019/02/16/layui-引入插件/","category":"layui"},{"title":"layui 使用layui 扩展组件 dtree","link":"//aha.me/2019/02/16/layui-使用layui-扩展组件-dtree/","description":"","pubDate":"Sat, 16 Feb 2019 14:56:14 GMT","guid":"//aha.me/2019/02/16/layui-使用layui-扩展组件-dtree/","category":"layui"}]}